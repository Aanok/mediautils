#!/bin/bash
# run as 'ffmpeg [...] </dev/null >/dev/null 2>/var/log/ffmpeg.log &' for background execution
# to grab all streams from the first input file, inlcuding attachments, use '-map 0'
# to grab all attachments from the first input file use '-map 0:t'
# to encode with 10 bits of colour depth use '-pix_fmt yuv420p10'
# to strip the final dot and extension from $x use '${x%.*}'
# if you need to reencode audio use Opus: '-c:a libopus -vbr on -compression_level 10 -b:a 128000' (64kbps per channel)
# to set all audio streams to 2 channels: '-ac 2' (note this will just copy over FL and FR channels without any mixing)
# to convert 5.1 sound to stereo for all audio streams with good volume levels: '-af "pan=stereo|FL=FC+0.30*FL+0.30*BL|FR=FC+0.30*FR+0.30*BR"'
# to encode in 720p with blackbanding use '-s hd720 -aspect 16:9' (this for 720p output; aspect adds the black bands)

##### NB: ffmpeg was programmed by a herd of baboons, so tty options have to be passed as an array instead of a string


# conveniency function printing help/usage information
usage() {
  echo "Usage:"
  echo " $0 [ --map-args <stream mapping options> ] [ --opus ] [ --downmix-stereo ] [ --outdir <output directory> ] [ 
--metadata-args <metadata labelling options> ] [ --keep-size ] [ --crf <CRF> ]"
  echo " $0 --help | -h"
}

# convenciency function printing an error message when an options requries a non-empty argument following but there isn't one
missing_arg_error() {
	printf 'ERROR: "%s" requires a non-empty option argument.\n' "$1" >&2
}
  

##### PRELIMINARIES #####

# parse command-line options
while :; do
  case "$1" in
    -h|--help)
    # print usage information
      usage
      exit
      ;;
    --map-args)
    # set stream mapping
      if [ -n "$2" ]; then
        MAPARGS=( $2 )
        shift
      else
        missing_arg_error "--map-args"
        exit 1
      fi
      ;;
    --opus)
    # set audio conversion to Opus
      AUDIOCODEC=(libopus -vbr on -compression_level 10 -b:a 128000)
      ;;
    --downmix-stereo)
    # set downmix of 5.1 surround channels to stereo
      DOWNMIX=(-ac 2 -af 'pan=stereo|FL=FC+0.30*FL+0.30*BL|FR=FC+0.30*FR+0.30*BR')
      ;;
    --outdir)
    # set output directory
      if [ -n "$2" ]; then
        OUTDIR="$2"
        shift
      else
        missing_arg_error "--outdir"
        exit 1
      fi
      ;;
    --metadata-args)
    # set metadata labelling
      if [ -n "$2" ]; then
        METADATAARGS=( $2 )
        shift
      else
        mising_arg_error "--metadata-args"
        exit 1
      fi
      ;;
    --keep-size)
    # set if keeping source file dimensions
      SIZE=1
      ;;
    --crf)
    # set CRF
      if [ -n "$2" ]; then
        CRF="$2"
        shift
      else
        mising_arg_error "--crf"
        exit 1
      fi
      ;;
    -?*)
		# unrecognized
			printf 'ERROR: Unkown option "%s"\n' "$1" >&2
			usage
			exit 1
			;;
		*)
		# end of options, leave case statement
			break
			;;
  esac
  shift
done

# if --outdir was not passed, use default
if [ -z "$OUTDIR" ]; then
  # default output directory is called 'reencode'
  OUTDIR=reencode
fi

# if --map-args was not passed, use default
if [ -z "$MAPARGS" ]; then
  # default is to grab all streams
  MAPARGS=('-map' '0')
fi

# if --opus was not passed, use default
if [ -z "$AUDIOCODEC" ]; then
  # default is to copy the audio streams over
  AUDIOCODEC="copy"
fi

# if --keep-size was not passed, use default
if [ -z "$SIZE" ]; then
  # by default we enforce a 720p height, proportional width. For a 16:9 input, this will give 720p resolution.
  # note HEVC requires even height size, hence the -2
  SIZE=('-vf' 'scale=w=-2:h=720')
else
  # to keep the original size, we don't pass anything to ffmpeg
  SIZE=( )
fi

# if --crf was not passed, use default
if [ -z "$CRF" ]; then
  # default is 20
  CRF="20"
fi

# figure out a task name
shopt -s extglob
if [[ "$PWD" == */[sS]@(eason\ +([0-9])|pecial?(s))* ]]; then
	taskname="${PWD%%/[sS]@(eason\ +([0-9])|pecial?(s))*}"
	taskname="${taskname##*/}"
else
	taskname="${PWD##*/}"
fi

# figure out if background execution
if [[ $(ps -o stat= -p $$) == *+* ]]; then
	# Running in foreground
  STDINSRC='/dev/stdin'
  STDOUTDEST='/dev/stdout'
  STDERRDEST='/dev/stderr'
else
  # Running in background
  STDINSRC='/dev/null'
  STDOUTDEST='/dev/null'
  STDERRDEST='ffmpeg.log'
fi


##### WORK #####

# create output directory if it doesn't exist
if [ ! -d "$OUTDIR" ]; then mkdir "$OUTDIR"; fi

# compute list of input and output
declare -a INPUT
declare -a OUTPUT
i=0
for x in *.@(mkv|mp4|avi); do
  INPUT[$i]="$x"
  OUTPUT[$i]="${x%.*}.mkv"
  ((i++))
done


# we'll keep track of successes and failures
successes=( )
failures=( )
# execute actual reencoding operations
i=0
while [ -n "${INPUT[$i]}" ]; do
  ARGS=(-n -i "${INPUT[$i]}" "${SIZE[@]}" -pix_fmt yuv420p10 "${MAPARGS[@]}" "${METADATAARGS[@]}" -c:v libx265 -preset slow -crf "${CRF[@]}" -c:a "${AUDIOCODEC[@]}" -c:s copy "${DOWNMIX[@]}" "./$OUTDIR/${OUTPUT[$i]}")
	
  if ffmpeg "${ARGS[@]}" <$STDINSRC >$STDOUTDEST 2>$STDERRDEST; then
  # ffmpeg exited with success, file should have been reencoded
    successes=( "${successes[@]}" "${OUTPUT[$i]}" )
  else
    # there was a failure of some kind
		failures=( "${failures[@]}" "${INPUT[$i]}" )
  fi
  ((i++))
done


##### EMAIL NOTIFICATION #####

# setup start of body of mail notification
if [ -f mailbody ]; then rm mailbody; fi
echo 'Reencoding attempt of' "$taskname" 'completed.' >> mailbody
echo >> mailbody

# complete body of mail notification
if [ ${#successes[@]} = 0 ]; then
	echo 'No file was successfully reencoded.' >> mailbody
else
	echo "The following files were successfully generated under directory $OUTDIR:" >> mailbody
	printf '%s\n' "${successes[@]}" >> mailbody
fi
echo >> mailbody

if [ ${#failuress[@]} = 0 ]; then
  echo 'All input files were processed.' >> mailbody
else
  echo 'There was an error processing the following files:' >> mailbody
  printf '%s\n' "${failures[@]}" >> mailbody
fi

# send mail notification
cat mailbody | mail -s "Reencoding $taskname" fabrizio07@gmail.com >$STDOUTDEST 2>$STDERRDEST

# cleanup
rm mailbody
