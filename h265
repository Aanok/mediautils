#!/bin/bash
# run as 'ffmpeg [...] </dev/null >/dev/null 2>/var/log/ffmpeg.log &' for background execution
# to grab all streams from the first input file, inlcuding attachments, use '-map 0'
# to grab all attachments from the first input file use '-map 0:t'
# to encode with 10 bits of colour depth use '-pix_fmt yuv420p10'
# to strip the final dot and extension from $x use '${x%.*}'
# if you need to reencode audio use Opus: '-c:a libopus -vbr on -compression_level 10 -b:a 128000' (64kbps per channel)
# to set all audio streams to 2 channels: '-ac 2' (note this will just copy over FL and FR channels without any mixing)
# to convert 5.1 sound to stereo for all audio streams with good volume levels: '-af "pan=stereo|FL=FC+0.30*FL+0.30*BL|FR=FC+0.30*FR+0.30*BR"'
# to encode in 720p with blackbanding use '-s hd720 -aspect 16:9' (this for 720p output; aspect adds the black bands)

##### NB: ffmpeg was programmed by a herd of baboons, so tty options have to be passed as an array instead of a string


# conveniency function printing help/usage information
usage() {
	echo "Usage:"
	echo "$0
	--map-args <stream mapping options> (default: -map 0) (please pass them in single quotes)
	--opus [bitrate]
	--downmix-stereo
	--outdir <output directory> (default: ./reencode)
	--wipe-metadata
	--keep-size
	--crf <CRF> (default: 20)
	--misc-args <arbitrary ffmpeg arguments> (please pass them in single quotes)"
}

# convenciency function printing an error message when an options requries a non-empty argument following but there isn't one
missing_arg_error() {
	printf 'ERROR: "%s" requires a non-empty option argument.\n' "$1" >&2
}
  

##### PRELIMINARIES #####

# set defaults

# OUTPUT DIRECTORY
OUTDIR=reencode

# STREAM MAPPING
MAPARGS=('-map' '0')

# AUDIO CODEC
AUDIOCODEC="copy"

# VIDEO QUALITY
CRF="20"

# RESOLUTION
# by default we enforce a 720p height, proportional width. For a 16:9 input, this will give 720p resolution.
# note HEVC requires even height size, hence the -2
SIZE=('-vf' 'scale=w=-2:h=720')


# parse command-line options
while :; do
  case "$1" in
    -h|--help)
    # print usage information
      usage
      exit
      ;;
		--map-args)
		# set stream mapping
      if [ -n "$2" ]; then
				# mind the lack of quotes for $2: Bash is a special boy when strings start with -
        MAPARGS=( $2 )
        shift
      else
        missing_arg_error "--map-args"
        exit 1
      fi
      ;;
    --misc-args)
    # arbitrary arguments
      if [ -n "$2" ]; then
				# likewise lack of quotes, see above
        MISCARGS=( $2 )
        shift
      else
        missing_arg_error "--misc-args"
        exit 1
      fi
      ;;
    --opus)
    # set audio conversion to Opus
      AUDIOCODEC=('libopus' '-vbr' 'on' '-compression_level' '10' '-b:a')
      # check for optional bitrate argument
      # please note [[ instead of [, it is required for the regex comparison
      if [[ -n "$2" && "$2" != -* ]]; then
        AUDIOCODEC=( "${AUDIOCODEC[@]}" "$2" )
        shift
      else
        AUDIOCODEC=( "${AUDIOCODEC[@]}" "128000" )
      fi
      ;;
    --downmix-stereo)
    # set downmix of 5.1 surround channels to stereo
      DOWNMIX=(-ac 2 -af 'pan=stereo|FL=FC+0.30*FL+0.30*BL|FR=FC+0.30*FR+0.30*BR')
      ;;
    --outdir)
    # set output directory
      if [ -n "$2" ]; then
        OUTDIR="$2"
        shift
      else
        missing_arg_error "--outdir"
        exit 1
      fi
      ;;
    --wipe-metadata)
    # start from blank slate metadata in output file (NB will preserve chapters)
    # we will however always carry attachment metadata, because it is mandatory lest errors arise
      METADATAARGS=( "${METADATAARGS[@]}" '-map_metadata' '-1' '-map_metadata:s:t' '0:s:t' )
      ;;
    --keep-size)
    # set if keeping source file dimensions
      SIZE=( )
      ;;
    --crf)
    # set CRF
      if [ -n "$2" ]; then
        CRF="$2"
        shift
      else
        mising_arg_error "--crf"
        exit 1
      fi
      ;;
    -?*)
		# unrecognized
			printf 'ERROR: Unkown option "%s"\n' "$1" >&2
			usage
			exit 1
			;;
		*)
		# end of options, leave case statement
			break
			;;
  esac
  shift
done


# we always add CRF to video stream metadata
METADATAARGS=( "${METADATAARGS[@]}" '-metadata:s:v:0' "H265_CRF=$CRF" )


# figure out a task name
shopt -s extglob
if [[ "$PWD" == */[sS]@(eason\ +([0-9])|pecial?(s))* ]]; then
	taskname="${PWD%%/[sS]@(eason\ +([0-9])|pecial?(s))*}"
	taskname="${taskname##*/}"
else
	taskname="${PWD##*/}"
fi

# figure out if background execution
if [[ $(ps -o stat= -p $$) == *+* ]]; then
	# Running in foreground
  STDINSRC='/dev/stdin'
  STDOUTDEST='/dev/stdout'
  STDERRDEST='/dev/stderr'
else
  # Running in background
  STDINSRC='/dev/null'
  STDOUTDEST='/dev/null'
  STDERRDEST='ffmpeg.log'
fi


##### WORK #####

# create output directory if it doesn't exist
if [ ! -d "$OUTDIR" ]; then mkdir -p "$OUTDIR"; fi

# compute list of input and output
declare -a INPUT
declare -a OUTPUT
i=0
for x in *.@(mkv|mp4|avi); do
  INPUT[$i]="$x"
  OUTPUT[$i]="${x%.*}.mkv"
  ((i++))
done


# we'll keep track of successes and failures
successes=( )
failures=( )
# execute actual reencoding operations
i=0
while [ -n "${INPUT[$i]}" ]; do
  ARGS=(-n -i "${INPUT[$i]}" "${SIZE[@]}" -pix_fmt yuv420p10 "${MAPARGS[@]}" "${METADATAARGS[@]}" -c:v libx265 -preset slow -crf "${CRF[@]}" -c:a "${AUDIOCODEC[@]}" -c:s copy "${DOWNMIX[@]}" "${MISCARGS[@]}" "./$OUTDIR/${OUTPUT[$i]}")
	
  if ffmpeg "${ARGS[@]}" <$STDINSRC >$STDOUTDEST 2>$STDERRDEST; then
  # ffmpeg exited with success, file should have been reencoded
    successes=( "${successes[@]}" "${OUTPUT[$i]}" )
  else
    # there was a failure of some kind
		failures=( "${failures[@]}" "${INPUT[$i]}" )
  fi
  ((i++))
done


##### EMAIL NOTIFICATION #####

# setup start of body of mail notification
if [ -f mailbody ]; then rm mailbody; fi
echo 'Reencoding attempt of' "$taskname" 'completed.' >> mailbody
echo >> mailbody

# complete body of mail notification
if [ ${#successes[@]} = 0 ]; then
	echo 'No file was successfully reencoded.' >> mailbody
else
	echo "The following files were successfully generated under directory $OUTDIR:" >> mailbody
	printf '%s\n' "${successes[@]}" >> mailbody
fi
echo >> mailbody

if [ ${#failuress[@]} = 0 ]; then
  echo 'All input files were processed.' >> mailbody
else
  echo 'There was an error processing the following files:' >> mailbody
  printf '%s\n' "${failures[@]}" >> mailbody
fi

# send mail notification
cat mailbody | mail -s "Reencoding $taskname" fabrizio.baldini@protonmail.com >$STDOUTDEST 2>$STDERRDEST

# cleanup
rm mailbody
